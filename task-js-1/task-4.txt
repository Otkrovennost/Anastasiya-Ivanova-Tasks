Explain each result of expressions in comments:
_____________________________________________________________________________________________________
1 - '0' + 2 // 3 

1 и 2 - числа, '0' - строка,'0' преобразуется в число 0 
и дальше  1 - 0 + 2 = 3. 
Остальные математические операторы работают только с числами и всегда преобразовывают операнды в число.
Если бы было +'0', например, то бинарный + производил бы соединение(конкатенацию) строк ( если хотя бы один операнд является строкой, то остальные будут также преобразованы в строку) и в результате  конкатенации строк вывелось бы 102
_____________________________________________________________________________________________________
1 - '-0' + 2 // 3

Аналогично предыдущему логика.'-0' -преобразуется в число, просто 0. И далее 1 - 0 + 2 = 3
_____________________________________________________________________________________________________
1 - '-0-' + 'NaN' // 'NaNNaN'

'-0-' не может быть преобразовано в число. Операция 1 - '-0-' выведет NaN, специальный символ в js, означает не число(Not A Number)(некорректное, недействительное число). Операция, у которой один из двух операндов не является числом, выдаст значение NaN. Далее срабатывает объединение в одну строку, так как следует строка далее. Первый NaN  преобразуется в строку и происходит конкатенация строк.  
______________________________________________________________________________________________________
'b' + [NaN + 'ba', 'CC'] - {} // NaN

1. [NaN + 'ba', 'CC'] - выдаст массив из двух элементов [ 'NaNba', 'CC' ], здесь для первого элемента сработает объединение строк, так как часть 'ba' - строка.
2. Далее: 'b' + [NaN + 'ba', 'CC'] выведет строку 'bNaNba,CC', потому что 'b' - строка. Опять срабатывает бинарный + для конкатенации строк и второй операнд преобразовывается в строку. 
3. 'bNaNba,CC' - {} вернет NaN(Not A Number), потому что результат математической операции данной(вычитания) не является числом.
_________________________________________________________________________________________________________
[] + (()=>{}) // '()=>{}'

1. Будет следующая цепочка функций: valueOf() -> toString()
Метод obj.valueOf(), так как он возвращает сам массив, который примитивом не является. Вызывается toString(), который вернет пустую строку.
2. Пустая строка + (()=>{}) выведет строку '()=>{}' - конкатенация строк
_________________________________________________________________________________________________________
[] + (()=>({})) // '()=>({})'

Аналогично с предыдущим логика
С пустым масисивом логика действительно аналогична с предудущим вариантом, вернет пустую строку. 
С вторым выражение так и не разобралась до конца, почему скобки отбрасываются. 
__________________________________________________________________________________________________________
[] + (()=>({}))() // '[object Object]'

1. Будет следующая цепочка функций: valueOf() -> toString()
Метод obj.valueOf() проигнорируется, так как он возвращает сам массив, который примитивом не является. Вызывается toString(), который вернет пустую строку.
2. Насколько понимаю, опять применяется метод для преобразования к примитиву по аналогичной цепочке: valueOf() -> toString(). obj.valueOf() - игнорируется и потом  вызывается метод toString(). Выводтся [object Object], потому что это   строковое представление по умолчанию в js типа Object. 
3. Конкатенация строк: пустая строка  + строка [object Object]
___________________________________________________________________________________________________________
[] + (() => new Object(123))() // '123'

1. Будет следующая цепочка функций: valueOf() -> toString()
Метод obj.valueOf() проигнорируется, так как он возвращает сам массив, который примитивом не является. Вызывается toString(), который вернет пустую строку.
2. Вызов функции (() => new Object(123))() выведет [Number: 123] 
  Предполагаю, что потому что эта математическая операция и изначально будет происходить вызов метода valueOf() для преобразования к числу.
3. Но так как первый операнд строка, то дальше преобразуется второй операнд в строку '123'
4. Конкатенация строк: '' + '123' = '123'
__________________________________________________________________________________________________________
{} + (() => new Object(123))() // 123

1. {} -  интерпретируется как блок кода, потому что стоит на первом месте и не считывается как часть выражения и после него автоматически интерпретатор будет ставить ;
2. Вызов функции (() => new Object(123))() выведет [Number: 123] - 123
  Думаю, потому  что будет происходить вызов метода valueOf() для преобразования к числу(так как часть математического выражения).
3.Далее {} игнорируется, остается +123, получаем число 123
___________________________________________________________________________________________________________
(() => new Object(123))() + {} // '123[object Object]'

1. Вызов функции (() => new Object(123))() выведет [Number: 123] - 123
2. {} - получим [object Object] (строковое представление объекта)
3. Конкатенация строк: первый операнд преобразуется в строку, раз 2 идет в строковом представлении (бинарный + здесь соединяет строки)
____________________________________________________________________________________________________________
({}).valueOf() + 1 // '[object Object]1'

Здесь тоже  выводит строковое представление объекта - первый операнд, поэтому срабатывает объединение строк
____________________________________________________________________________________________________________
{} + 2 // 2

{} интерпретируется как блок кода и игнорируется. Выражение интерпретируется как +2. Выводит просто число 2.   
____________________________________________________________________________________________________________
typeof ({}).valueOf() + 2 // 'object2'

1. сначала сработает valueOf(), но он не сможет преобразовать к числовому значению. Затем typeof - обращаемся к типу    аргумента,  поэтому  выводит object в форме строки. 
2. Далее снова конкатенация строк, так как тип выводится в строковом представлении. 
___________________________________________________________________________________________________________
+{} // NaN

Цепочка по отношению к {}: valueOf() -> toString()
Потом пытаемся применить унарный +  к преобразованному к строковому формату примитиву.
Выводит NaN потому что результат не является числом.
___________________________________________________________________________________________________________
+{}+[] // 'NaN'

1. +{} выводит NaN(по логике выше)
2. Будет следующая цепочка функций: valueOf() -> toString()
Метод obj.valueOf() проигнорируется, так как он возвращает сам массив, который примитивом не является. Вызывается toString(), который вернет пустую строку. 
4. Первый операнд преобразуется в строку(раз один из операндов строка) и получается 'NaN'
3. Конкатенация строк: '' + 'NaN' = 'NaN'
___________________________________________________________________________________________________________
+[] // 0

Сначала для [] опять же следующая цепочка функций: valueOf() -> toString()
Метод obj.valueOf() проигнорируется, так как он возвращает сам массив, который примитивом не является. Вызывается toString(), который вернет пустую строку. Пустая строка - это false, поэтому возвращает 0.
_________________________________________________________________________________________________________
+[]+{} // '0[object Object]'

1. +[]  выведет 0
2. Второй операнд {} - объект в строковом представлении [object Object]
3. Конкатенация строк, так как строковое представление второго операнда
___________________________________________________________________________________________________________
+[10, 1]+{} // 'NaN[object Object]'

1. +[10, 1] - не является числом, поэтому выведет NaN
2. {} - объект в строковом представлении [object Object]
3. Конкатенация строк
____________________________________________________________________________________________________________
{} + [10] // 10

1. {} - пустой блок кода
2. + преобразует операнд в чило и получим число 10.
____________________________________________________________________________________________________________